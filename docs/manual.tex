\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{siunitx}
\usepackage{listings}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{framed}
\hypersetup{
    colorlinks=false,
}

\newcommand{\packagename}[1]{\textit{#1}}
\newcommand{\thispackage}{\packagename{dimensional}}
\newcommand{\experimentalpackage}{\packagename{dimensional-dk-experimental}}
\newcommand{\flag}[1]{\textbf{#1}}
\newcommand{\prerelease}{\begin{framed}
The functionality discussed in this section has not yet been released.
\end{framed}}

\lstset{language=haskell,
numberstyle=\footnotesize,
basicstyle=\ttfamily\footnotesize,
breaklines=true}
\lstMakeShortInline[columns=fixed]`

\title{
	{Writing Physical Computations in Haskell with \thispackage}\\
	{\small{Version 1.1}}
}
\author{BjÃ¶rn Buckwalter and Douglas McClean}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

The \thispackage{} library provides data types for performing arithmetic with physical
quantities. Information about the physical dimensions of each quantity is embedded in
its type.

This allows the compiler to statically verify that no dimensional mistakes have been
made in a calculation. It also facilitates interconversion between quantities expressed
in different units and provides documentation of the dimension and units of each physical
quantity a program manipulates.

\section{Installation}

The latest version of \thispackage{} can be installed in the usual way, using the following commands:

\begin{lstlisting}[language=bash]
cabal update
cabal install dimensional
\end{lstlisting}

Historical versions and Haddock documentation are available at \url{http://hackage.haskell.org/package/dimensional}.

\section{\thispackage{} in Five Minutes}

It's extremely easy to get started using the \thispackage{} library.

\begin{lstlisting}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE NoMonomorphismRestriction #-}

import Numeric.Units.Dimensional.Prelude

-- The list of quantity synonyms in Numeric.Units.Dimensional.Quantities
-- makes declaring everything from Length to MagneticFluxDensity easy.
radiusOfEarth :: Length Double
radiusOfEarth = 6371 *~ kilo meter
  -- Use the *~ operator to multiply a raw number by a Unit, 
  -- forming a Quantity. The /~ operator divides a Quantity
  -- by a Unit yielding a raw number and is useful for
  -- transferring results to code which is not dimensionally-typed.

massOfEarth :: Mass Double
massOfEarth = 5.97e24 *~ kilo gram

-- Types can be inferred for most operations, although in some
-- circumstances (like this one) it may require activating
-- the NoMonomorphismRestriction extension.
g = 6.67384e-11 *~ (newton * (meter / kilo gram)^pos2)
  -- Combine units using multiplication, division, and exponentiation.
  -- pos3, neg1, etc. are proxies for type-level integers
  -- from the numtype-dk library.

-- You can easily declare functions that are polymorphic in the
-- numeric representation type.
gravitationalFieldStrength :: (Fractional a) => Mass a 
                                             -> Length a
                                             -> Acceleration a
gravitationalFieldStrength m r = g * m / r^pos2
  -- Exponentiation of quantities uses the same proxies as does
  -- exponentiation of units.

approximateAccelerationDueToGravityOnEarth = gravitationalFieldStrength massOfEarth radiusOfEarth
  -- Showing this yields: "9.816008178047202 m s^-2"
\end{lstlisting}

\section{Licensing}

The \thispackage{} package is provided under a BSD 3-clause license.

\section{Contributing}

Contributions to \thispackage{} development, in the form of bug reports,
feature requests, or pull requests, are welcome. The source code repository and issue
tracker are both hosted by GitHub at \url{https://github.com/bjornbm/dimensional}.

\chapter{Dimensional Arithmetic}

\chapter{Manipulating Units}

Although most dimensional arithmetic involves manipulating quantities, it is sometimes necessary
to manipulate units themselves. It's possible to combine units by multiplying or dividing them, or to
form new units from existing ones by applying metric prefixes.

A unit of dimension `d` is represented by a value of type `Unit m d a`. Because only certain units can
accept metric prefixes, the type parameter `m` tracks the `Metricality` of the unit. As with quantities,
the final type parameter is the representation type, for units this is the value of the conversion factor
from the unit to its dimension's coherent SI unit.

\section{Unit Arithmetic}

The `*` operator from `Numeric.Units.Dimensional` not only forms the product of two quantities, it can also
form the product of two units. Similarly, the `/` and `^` operators works on units as well as on quantities.
Narrowing the types to look only at how they operates on units:

\begin{lstlisting}
(*) :: (Num a) => Unit m1 d1 a -> Unit m2 d2 a -> Unit 'NonMetric (d1 * d2) a
(/) :: (Fractional a) => Unit m1 d1 a -> Unit m2 d2 a
                      -> Unit 'NonMetric (d1 * d2) a
(^) :: (Fractional a, KnownTypeInt i) => Unit m d a -> Proxy i
                                      -> Unit 'NonMetric (d ^ i) 
\end{lstlisting}

As one would expect, the dimension of a product or quotient is the product or quotient of the dimensions of the operands.
Raising a unit to an integer power raises the dimension to the same power, which requires a `Fractional` context as the
power may be negative.

Each metric prefix defined by the SI is provided as a function with the same name as the prefix in the `Numeric.Units.Dimensional.SIUnits` module.
The prefixes which define multiples of a unit, such as kilo and giga, have type `Num a => Unit 'Metric d a -> Unit 'NonMetric d a`.
Those which define submultiples of a unit, such as micro and atto, require a `Fractional` context instead.

A `Unit` in one representation type may be converted to another using the same functions as are provided for quantities.
Again narrowing the types to look only at how they operates on units:

\begin{lstlisting}
changeRep :: (Real a, Fractional b)  => Unit m d a       -> Unit m d b
changeRepApproximate :: (Floating b) => Unit m d ExactPi -> Unit m d b
\end{lstlisting}

It's also possible to form the exact version of a `Unit` using:

\begin{lstlisting}
exactify :: Unit m d a -> Unit m d ExactPi
\end{lstlisting}

Moving back and forth between `Metric` and `NonMetric` units can be accomplished when needed using:

\begin{lstlisting}
weaken     :: Unit m d a -> Unit 'NonMetric d a
strengthen :: Unit m d a -> Maybe (Unit 'Metric d a)
\end{lstlisting}

Taken together, these operators and functions are quite flexible in allowing new units to be formed from
the combination of existing units. Support for creating new units will be discussed in \ref{constructing-new-units} after
the concept of unit names has been introduced.

\section{Unit Names}

\subsection{Interchange Names}
\subsection{Unit Name Normal Forms}

\section{Constructing New Units} \label{constructing-new-units}

New units may be constructed using one of three functions, depending on whether the required conversion factor to the coherent
SI unit of the same dimension is an integer, a rational number, or involves the mention of $ \pi $.

\begin{lstlisting}
mkUnitZ :: Num a        => UnitName m -> Integer  -> Unit m1 d a -> Unit m d a
mkUnitQ :: Fractional a => UnitName m -> Rational -> Unit m1 d a -> Unit m d a
mkUnitR :: Floating a   => UnitName m -> ExactPi  -> Unit m1 d a -> Unit m d a
\end{lstlisting}

Taking an example (already provided in the `Numeric.Units.Dimensional.NonSI` module), one might define:

\begin{lstlisting}
usGallon, usQuart :: (Fractional a) => Unit 'NonMetric DVolume a
usGallon = mkUnitQ (ucum "[gal_us]" "gal" "gallon") 231             (cubic inch)
usQuart  = mkUnitQ (ucum "[qt_us]"  "qt"  "quart")  (1 Prelude./ 4) usGallon
\end{lstlisting}

Each requires as arguments the name of the unit to be formed, the scale factor relating it to a unit which has already been defined,
and that unit. In addition to the constraints verified by the type system, these functions further check that the supplied scale factor is
strictly positive, and that when combined with the scale factor in the defining unit the scale factor of the resulting defined unit remains
within the appropriate class of values.

Note in the example that even though the `usGallon` is defined to be an integer multiple of its defining unit, the `cubic inch`, it is nevertheless
necessary to use `mkUnitQ` instead of `mkUnitR`. This is because the `cubic inch` is not an integer multiple of the SI coherent unit of volume, the cubic meter.

Users should feel free to submit pull requests to \thispackage{} for any units that are useful to their work which are not included.




\chapter{Dimensional Vectors}

It's frequently convenient to manipulate vectors of dimensional values. Because such vectors often have heterogenous
dimensions, existing Haskell vector libraries are a poor solution. In order to retain dimensional typing in these situations,
\thispackage{} offers a standard representation for dimensional vectors, however it does not include a full-featured system for
dimensional linear algebra. A package using \thispackage{} and \packagename{hmatrix} to do so is under early-stage development.





\chapter{Dynamic Dimensions}

Statically tracked dimensions are wonderful and vastly simplify development of code that works with quantities of specific
dimensions. However there are times when we might wish to manipulate quantities or units of unknown dimensions. This can be
especially useful when parsing user input.

The `Numeric.Units.Dimensional.Dynamic` module provides a number of features for manipulating quantities or units with dimensions that are only
known dynamically.

\section{Dynamic Quantities}

The `AnyQuantity` type represents a quantity whose dimension is only known dynamically. One use of this
type, for example, is to read dimensional values from a configuration file. In a context where
`parseQuantity :: Text -> AnyQuantity Scientific` one might write:

\begin{lstlisting}
readMaximumSpeed :: Text -> Maybe (Velocity Double)
readMaximumSpeed config = fmap changeRep . promoteQuantity . parseQuantity
\end{lstlisting}

Quantities can be demoted to dynamic quantities, and dynamic quantities can be promoted back into quantities,
using the functions below:

\begin{lstlisting}
demoteQuantity  :: (Demoteable q, Promoteable d) => q a -> d a
promoteQuantity :: (Demoteable q, Promoteable d) => d a -> Maybe (q a)
\end{lstlisting}

The `Demoteable` class includes both `Quantity d` and `AnyQuantity`, while the `Promoteable` class includes both
`AnyQuantity` and `DynQuantity`. These classes are provided because, in addition to `AnyQuantity`, there is also a more general type, `DynQuantity`.
While an `AnyQuantity a` value definitely represents a `Quantity` of some dimension, a `DynQuantity a` value may not.
This is a useful property because it admits a complete and well-behaved `Num` instance for `DynQuantity` which allows
arithmetic to be performed with dynamic quantities which is nonetheless dimensionally verified at runtime. For example,
the result of `demoteQuantity (3 *~ meter) + demoteQuantity (47 *~ second)` cannot be successfully promoted to an
`AnyQuantity`, or to a `Quantity` of any dimension.

\section{Dynamic Units}

It is also occasionally convenient to manipulate units with unknown dimensions. The `AnyUnit` type provides
an analogue of `AnyQuantity` for `Unit`s.

Similar promotion and demotion functions are available:

\begin{lstlisting}
demoteUnit  :: (KnownDimension d) => Unit m d a -> AnyUnit
promoteUnit :: (KnownDimension d) => AnyUnit
                                  -> Maybe (Unit 'NonMetric d ExactPi)
\end{lstlisting}

Because all `Unit m d a` values carry their conversion factor represented as an `ExactPi` value alongside their value in
the type `a`, it's not necessary for `AnyUnit` to carry a type parameter. When promoting an `AnyUnit` we always represent
the result using `ExactPi`, if you desire a different representation you can use `changeRepApproximate` to obtain one.
Similarly, while the result of promotion is always tagged as `NonMetric`, you can use `strengthen` to attempt to convert
it to a `Metric` unit.

Arithmetic operations `*`, `/`, `^`, and `recip` are provided for manipulating `AnyUnit`s. There is no need for an analogue
of `DynQuantity` for these operations, because they are all total. An `applyPrefix :: Prefix -> AnyUnit -> Maybe AnyUnit`
function is available for dynamically applying metric prefixes to units, it will return `Nothing` if the unit was not `Metric`.

Dynamic analogues of `*~` and `/~` allow the use of dynamic units to convert between raw values and dynamic quantities, as:

\begin{lstlisting}
(*~) :: (Floating a, Promoteable q) =>   a -> AnyUnit -> q a
(/~) :: (Floating a, Promoteable q) => q a -> AnyUnit -> Maybe a
\end{lstlisting}

Note that `/~` will return `Nothing` if the dimensions of the supplied dynamic quantity do not match those of the
dynamic unit. The `Floating` context is required for both operations because the conversion factor of the
dynamic unit may involve $ \pi $.



\chapter{Fixed Point Dimensional Arithmetic}

\prerelease{}

Although floating point arithmetic is fast and convenient for many applications, the \thispackage{} package also provides
support for performing fixed point computations with dimensional values.

Using the \packagename{exact-pi} package's support for type-level positive rationals extended with an exact representation
of $ \pi $, \thispackage{} statically encodes the scale factor between the least significant bit of the chosen `Integral`
representation and the coherent SI unit of the quantity's dimension. This allows fixed point representations to be
treated uniformly and correctly by arithmetic operations without requiring the programmer to appropriately scale the results
before storing them.

\section{Describing Fixed-Point Quantity Types}

The familiar `Quantity` type is an alias for `SQuantity One` (where `One`) is the \packagename{exact-pi}
package's representation of the number $ 1 $. While it is possible to use `SQuantity` with other scaling factors and a
floating point or exact rational representation type, it is rarely necessary to do so because the range of common floating
point representations can comfortably encode both very large and very small physical quantities directly represented in the
coherent SI unit of their dimension.

Where `SQuantity` becomes more directly useful, and where special fixed point support is required, is when an
`Integral` representation type is desired. For example, an embedded system may wish to encode the estimated
velocity of a vehicle as a 16-bit signed integer with a minimum increment of \SI{1}{\centi\meter\per\second}. It is common
to represent such a value by a variable of type `Int16` and an accompanying comment or naming convention indicating
the dimension and scale factor, but \thispackage{} provides a more expressive type, which can be written in one of several ways.

\subsection{Without Template Haskell}

Without using Template Haskell, one could write:

\begin{lstlisting}
import Numeric.Units.Dimensional.FixedPoint.Prelude
import qualified Data.ExactPi.TypeLevel as E
import Data.Int

type VehicleSpeed = SQuantity (E.One E./ (E.ExactNatural 100)) DLength Int16
\end{lstlisting}

\subsection{With Template Haskell} \label{fixed-point-th}

With Template Haskell either of the following simpler forms is equivalent to the one given above:

\begin{lstlisting}
import Numeric.Units.Dimensional.FixedPoint.Prelude
import Numeric.Units.Dimensional.TH
import Data.Int

type VehicleSpeed1 = SQuantity [exact| 1/100 |] DLength Int16
type VehicleSpeed2 = [fixed| cm / s |] Int16
\end{lstlisting}

In the latter example, note that both the scale factor and dimension were determined by the type quasiquoter, and so it
only remained to specify the representation type.

TODO: give an example where the scale isn't an exact unit, other examples of accepted syntax for quasiquoter

\section{Fixed-Point Arithmetic}

TODO: give examples of performing arithmetic with such values

\subsection{Transcendental Functions}

The transcendental functions from `Numeric.Units.Dimensional` have types like:

\begin{lstlisting}
sin :: Floating a => Dimensionless a -> Dimensionless a
\end{lstlisting}

However when using fixed point values, we wish to use representation types which lack `Floating` instances. Accordingly,
the `Numeric.Units.Dimensional.FixedPoint` module provides transcendental functions with types like the one given below.
Note that as is often the case in the fixed point module, in order to provide maximal flexibility and preserve precision of
intermediate results, the result type of the operation is not fully determined by the type of its operand and instead is
determined from context.

\begin{lstlisting}
sin :: (KnownExactPi s1, KnownExactPi s2 Integral a) => SQuantity s1 DOne a -> SQuantity s2 DOne a
\end{lstlisting}

\chapter{Interoperating with Other Packages}

\section{\packagename{ad} for Automatic Differentiation}

\prerelease{}

\section{\packagename{aeson} for JSON Serialization}

\prerelease{}

Users of the \packagename{aeson} package can find `ToJSON`
and `FromJson` instances for `Quantity` and for certain ancillary types by
enabling the \flag{aeson} flag when installing \thispackage{}.

\section{\packagename{attoparsec} for Unit and Quantity Parsing}

\prerelease{}

Users of the \packagename{attoparsec} package can find parsers recognizing
unit names (both in natural language and in the UCUM interchange format) and
quantities in the \packagename{dimensional-attoparsec} package.

These parsers are also used by the \packagename{dimensional-th} package to provide
Template Haskell quasi-quotations for quantities and for fixed-point types, as
discussed in \ref{fixed-point-th}.

\section{\packagename{binary} for Binary Serialization}

\prerelease{}

Users of the \packagename{binary} package can find `Binary`
instances for `Quantity` and for certain ancillary types by
enabling the \flag{binary} flag when installing \thispackage{}.

\section{\packagename{cereal} for Binary Serialization}

\prerelease{}

Users of the \packagename{cereal} package can find `Serialize`
instances for `Quantity` and for certain ancillary types by
enabling the \flag{cereal} flag when installing \thispackage{}.

\section{\packagename{HaTeX} for \LaTeX{} Generation}

\prerelease{}

\section{\packagename{ihaskell} for Interactive Notebooks}

\prerelease{}

The IHaskell project provides support for interactive notebook documents containing
Haskell code through the Jupyter project.

Instances of `IHaskellDisplay` for `Quantity` and `Unit`
allow attractive \LaTeX{}-style display of dimensional values in your notebooks. These
instances can be found in the \\
`Numeric.Units.Dimensional.IHaskell` module of the \experimentalpackage{}
package.

\section{\packagename{lens}}

Todo: Without taking a dependency on lens, offer a declaration that can convert a unit into a lens from quantities to numeric values.
Explain here how to use that facility.

\section{\packagename{linear} for Linear Algebra}

\prerelease{}

Users of the \packagename{linear} package can find appropriate instances of
the `Additive` and `Affine` classes, along with an
instance of `Metric` for dimensionless quantities, by enabling the \flag{linear}
package flag when installing \thispackage{}.

The \flag{linear} flag implies the \flag{functor} flag and will result in generation of a `Functor`
instance for dimensional values.

\section{\packagename{time} for Times and Dates}

Users of the \packagename{time} package can find functions and lenses for converting
between the `DiffTime` representation and \thispackage{}'s `Time` representation in the
`Numeric.Units.Dimensional.Time` module of the \experimentalpackage{} package.

\section{\packagename{vector} for Boxed and Unboxed Arrays}

The \thispackage{} package provides instances of the `Vector` and `MVector` data families and the `Unbox` class
allowing `Quantity`s to be stored in unboxed vectors for improved performance and reduced storage overhead.

\section{\packagename{vector-space} for Linear Algebra}

\prerelease{}

Users of the \packagename{vector-space} package can find appropriate instances of the `AdditiveGroup` and \\
`VectorSpace` classes, along with an instance of `InnerSpace` for dimensionless quantities, by enabling the \flag{vector-space}
package flag when installing \thispackage{}.

\chapter{Libraries Using \thispackage}

\section{\packagename{atmos} for Modeling Earth's Atmosphere}

The \packagename{atmos} package provides a dimensionally-typed implementation of the 1976 International Standard
Atmosphere, a model of how pressure, temperature, the speed of sound, and related quantities vary with
altitude in the Earth's atmosphere.

\section{\packagename{igrf} for Modeling Earth's Magnetic Field}

\prerelease{}

The \packagename{igrf} package provides a dimensionally-typed implementation of the International Geomagnetic
Reference Field, including parsing of model text files in the format released by the International Association of
Geomagnetism and Aeronomy and the United States National Oceanographic and Atmospheric Administration. The
package also directly includes the model coefficients for the most recent model releases.

\chapter{Included Dimensions and Units}

\chapter{Comparison with Other Libraries}

\section{quantities}
\section{units}
\section{uom-plugin}

\end{document}

